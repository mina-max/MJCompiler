package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
	

:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}



terminal PROGRAM, BREAK, ENUM, DO, WHILE, NEW, CONST, CLASS, EXTENDS, READ;
terminal SEMI, RETURN, COMMA, PRINT, VOID, CONTINUE,  SWITCH, CASE;
terminal LBRACE, RBRACE, LBRACKET, RBRACKET, LPARENT, RPARENT, COLON, QUESTION;
terminal EQUAL, NOTEQ, GREATEREQ, GREATER, LESSEQ, LESS, PLUS, MINUS, MUL, DIV, MOD;
terminal AND, OR, ASSIGN, INC, DEC, DOT, YIELD;
terminal Integer NUMBER;
terminal String IDENT, CHAR;
terminal IF, ELSE, BOOL;

nonterminal Program, DeclList, Decl, ConstDecl, ConstDeclList, ConstDeclSingle, Init;
nonterminal VarDecl, VarDeclList, VarDeclSingle, ArrayOpt, ClassDecl, ExtendsOpt;
nonterminal MethodDeclList, MethodDecl, ReturnType, FormPars, FormParsList, FormParsSingle;
nonterminal Statement, DesignatorStatement, DesOperators, AssignOp, Condition;
nonterminal CondTerm, CondFact, RelopOpt, Relop, ElseOpt, Expr, Term, Factor, ActPars;
nonterminal CaseList, DesList, DesElement, StatementList, AddOp, MulOp, MethodDeclListOpt, VarDeclOnly;
nonterminal FormParsOpt, ActParsOpt, PrintParamOpt, ConditionCorrect, MethodBody, MethodSign, Do;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, ClassName, MethodName, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ReturnExprOpt;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;

precedence left ELSE;

Program 		::= (Program) PROGRAM ProgName DeclList LBRACE MethodDeclList RBRACE;

ProgName		::= (ProgName) IDENT:progName;

DeclList 		::= (Declarations) 	DeclList Decl
				|	(NoDecl) /* epsilon */;

Decl 			::= (ConstDeclaration) 	ConstDecl 
				|	(VarDeclaration)	VarDecl
				| 	(ClassDeclaration) 	ClassDecl;
		
ConstDecl 		::= (ConstDecl) CONST Type ConstDeclList SEMI;

ConstDeclList 	::= (ConstDeclListExpr) ConstDeclList COMMA ConstDeclSingle
				| 	(ConstDeclOne) ConstDeclSingle;

ConstDeclSingle ::= (ConstDeclSingle) IDENT:constName ASSIGN Init;

Init 			::= (NumberConst) NUMBER 
				| 	(CharConst)	 CHAR
				|	(BoolConst)	 BOOL;

Type			::= (Type) IDENT:typeName;

VarDecl 		::= (VarDeclExpr) Type VarDeclList SEMI
				|	(ErrorVarDecl) error;

VarDeclList 	::= (VarDeclListExpr) 	VarDeclList COMMA VarDeclSingle
				| 	(VarDeclOne) 	VarDeclSingle
				|	(ErrorVarDeclList)	error;

VarDeclSingle 	::= (VarDeclSingle) IDENT:varName ArrayOpt;

VarDeclOnly		::=	(VarDeclOnlyExpr) VarDeclOnly VarDecl
			  	|	(NoVars) /*epsilon*/; 

ArrayOpt		::=	(Array) LBRACKET RBRACKET
				| 	(NotArray) /* epsilon */;

ClassDecl		::= (ClassDecl) CLASS ClassName ExtendsOpt LBRACE VarDeclOnly MethodDeclListOpt RBRACE;

ClassName		::= (ClassName) IDENT:className;

ExtendsOpt		::= (ParentClass) EXTENDS Type
				|	(NoParentClass) /* epsilon */;

MethodDeclList	::= (MethodDeclListExpr) MethodDeclList MethodDecl
				|	(NoMethodDeclList) /* epsilon */;

MethodDecl		::= (MethodDecl) ReturnType MethodSign MethodBody;

MethodSign		::= (MethodSign) MethodName LPARENT FormParsOpt RPARENT;

MethodBody		::= (MethodBody) VarDeclOnly LBRACE StatementList RBRACE;

MethodName		::= (MethodName) IDENT:methodName;

MethodDeclListOpt ::= (MethodDeclListOptExpr) LBRACE MethodDeclList RBRACE
				  |   (NoMethodDeclListOpt) /* epsilon */;
				  

ReturnType		::= (ReturnTypeExpr) Type
				| 	(ReturnVoid) VOID;

FormParsOpt		::= (FormParsListOptExpr) FormParsList
				| 	(NoFormPars) /* epsilon */;

FormParsList	::= (FormParsListExpr) 	FormParsList COMMA FormParsSingle
				|	(FormParsOne)  		FormParsSingle
				|	(FormParsListError)	error;

FormParsSingle	::= (FormParsSingle) Type IDENT:formParName ArrayOpt;

Statement		::= (DesignatorStatementExpr) DesignatorStatement SEMI
				|	(IfCondition)		IF ConditionCorrect Statement
				|	(IfElseCondition)	IF ConditionCorrect Statement ELSE Statement
				|	(DoWhileStatement)	Do Statement WHILE LPARENT Condition RPARENT SEMI
				|	(YieldStatement)	YIELD Expr SEMI
				|	(BreakStatement)	BREAK SEMI
				|	(ContinueStatement) CONTINUE SEMI
				|	(ReturnStatement)	RETURN ReturnExprOpt SEMI
				|	(ReadStatement)		READ LPARENT Designator RPARENT SEMI
				|	(PrintStatement)	PRINT LPARENT Expr PrintParamOpt RPARENT SEMI
				| 	(ListStatement)		LBRACE StatementList RBRACE;

StatementList	::= (StatementListExpr) StatementList Statement
				| 	(NoStatement) /* epsilon */;
				
Do				::= (DoStatement)	DO;

DesignatorStatement ::= (AssignDes) Designator AssignOp Expr
					| 	(FuncDes)	Designator LPARENT ActParsOpt RPARENT
					|	(IncDes)	Designator INC
					|	(DecDes)	Designator DEC;

Designator		::= (Designator) IDENT:desName DesList;

DesList			::=	(DesListExpr) DesList DesElement
				| 	(NoDesList) /* epsilon */;
					
DesElement		::= (FieldIdent) DOT IDENT
				|	(ArrayIdent) LBRACKET Expr RBRACKET;		

AssignOp		::= (AssignOperator) 	ASSIGN
				|	(AssignError)		error;

ActPars			::= (ExprList) 	ActPars COMMA Expr
				|	(ExprPar) 		Expr;
				
ConditionCorrect::= (CorrectCondition) LPARENT Condition RPARENT
			     |	(ErrorCondition) LPARENT error RPARENT:l
			     {:parser.report_error("Izvrsen oporavak od greske na liniji " + lleft, null); :};
					
Condition		::= (CondExpr) 			Condition OR CondTerm
				| 	(CondTermSingle)	CondTerm;

CondTerm		::= (CondTermExpr) 		CondTerm AND CondFact
				|	(CondFactSingle)	CondFact;

CondFact		::= (CondFactExpr)	Expr RelopOpt;

RelopOpt		::= (RelopOptExpr) Relop Expr
				|	(NoRelop) /* epsilon */;

Relop			::= (EqualRel)		EQUAL 
				|	(NotEqualRel)	NOTEQ 
				| 	(GreaterEqRel)	GREATEREQ 
				|	(GreaterRel)	GREATER 
				| 	(LessEqRel)		LESSEQ 
				| 	(LessRel)		LESS;

Expr			::= (NegativeTerm)	MINUS Term
				|	(PositiveTerm)	Term
				|	(NotFirstTerm)	Expr AddOp Term;

Term			::= (TermExpr)		Term MulOp Factor
				|	(TermFactor)	Factor;
				
ReturnExprOpt	::= (ReturnExpression) Expr
				|	(NoExpression) /* epsilon */;

Factor			::= (DesFactor) 		Designator
				|	(DesFactorPars) 	Designator LPARENT ActParsOpt RPARENT
				|	(NumFactor) 		NUMBER
				|	(CharFactor)		CHAR
				|	(BoolFactor)		BOOL
				|	(NewArrayFactor)	NEW Type LBRACKET Expr RBRACKET
				|	(NewFactor)			NEW Type 
				|	(ExprFactor)		LPARENT Expr RPARENT;

ActParsOpt		::= (ActParsExpr) ActPars 
				|	(NoActPars) /* epsilon */;

PrintParamOpt	::= (PrintParam)	COMMA NUMBER
				|	(NoPrintParam) /* epsilon */;

AddOp			::= (Plus)  PLUS
				|	(Minus) MINUS;

MulOp			::= (Mul) MUL
				|	(Div) DIV
				|	(Mod) MOD;
				
				
				
				
				